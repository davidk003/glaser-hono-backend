import { chromium } from 'playwright-extra'
import StealthPlugin from 'puppeteer-extra-plugin-stealth'
import { Browser, ElementHandle, Page } from 'playwright';

interface gotoOptions {
  referer?: string;
  timeout?: number;
  waitUntil?: "load" | "domcontentloaded" | "networkidle" | "commit";
}

const gotoOptions: gotoOptions = { timeout: 10000, waitUntil: 'load' }

export async function scrapeName(url: string): Promise<string | null>
{
    chromium.use(StealthPlugin())
    const browser: Browser = await chromium.launch();
    const page: Page = await browser.newPage();

    try {
        let startTime = Date.now();
        await page.goto(url, gotoOptions);
        console.log(`Name goto took: ${Date.now() - startTime}ms`);

        const nameElement = await page.locator('[property="og:title"]').first();
        const actualName = await nameElement.getAttribute('content');

        return actualName;
    } catch (error) {
        await browser.close();
        // console.error('An error occurred:', error);
        return null;
    } finally {
        await browser.close();
    }

}

export async function scrapePostText(url: string): Promise<string[] | null>
{
    chromium.use(StealthPlugin())
    const browser: Browser = await chromium.launch();
    const page: Page = await browser.newPage();

    try {
        let startTime = Date.now();
        await page.goto(url, gotoOptions);
        console.log(`Post text goto took: ${Date.now() - startTime}ms`);
      // Consider data-ad-preview="message" can have more than one element for reposts/reply posts
        const postElement = await page.locator('[data-ad-preview="message"]').first();
        const contentSpan = await postElement.locator('div > div > span').first();
        const textBlockList = await contentSpan.locator('> div').all();
        console.log(textBlockList.length);
        let textContentList:string[] = [];
        for (const textBlock of textBlockList) {
            const text = await textBlock.innerText();
            textContentList.push(text);
        }
        return textContentList;
    } catch (error) {
        await browser.close();
        // console.error('An error occurred:', error);
        return null;
    } finally {
        await browser.close();
    }
}



export async function scrapeDate(url: string): Promise<string | null> {
    chromium.use(StealthPlugin())
    const browser: Browser = await chromium.launch();
    const page: Page = await browser.newPage();
  
    try {
        let startTime = Date.now();
        await page.goto(url, gotoOptions);
        console.log(`Date goto took: ${Date.now() - startTime}ms`);

        const parentElement = (await page.locator('[aria-labelledby]').all())[1];
    //   const childDiv = await parentElement.locator('span').first();
      
      const spans = await page.evaluate(() => {
        const parentElements = document.querySelectorAll('[aria-labelledby]');
        if (parentElements.length < 2) {
          throw new Error('Not enough elements found');
        }
        const childDiv : HTMLSpanElement | null = parentElements[1].querySelector('span');
        if (!childDiv) {
          throw new Error('Child div not found');
        }
        const spans = childDiv.querySelectorAll('span');
        return Array.from(spans).map(span => {
          return [span.textContent, (span.offsetTop === 0 ? span.offsetLeft : null)];
        });
      });
  
      // console.log(spans);
      
      //Remove all null values because they are fake characters
      const filteredSpans = spans.filter((el) => el[1] !== null);
      //Sort real characters by leftoffset to get true ordering
      filteredSpans.sort((a, b) => (a[1] as number) - (b[1] as number));
      //Add all sorted characters to get same date as displayed
      const date = filteredSpans.map(x => x[0]).join('');
      // console.log(filteredSpans);
  
      return date;
    } catch (error) {
      console.error('An error occurred:', error);
      await browser.close();
      return null;
    } finally {
      await browser.close();
    }
}


export async function scrapeImages(url: string): Promise<(string | null)[]>
{
  //Through img tags, then image tags with alt
  //Consider testing no image, multiple images, repost images
  //Upon observation, alt values are generated by facebook, and
  //More than one image leaves an empty alt value.
  //Reposts have a "No photo description available." alt value
    
    const imgSelector = `div > img[alt]`
    const browser: Browser = await chromium.launch();
    const page: Page = await browser.newPage();
    chromium.use(StealthPlugin())
    let startTime = Date.now();
    await page.goto(url, gotoOptions);
    console.log(`Image goto took: ${Date.now() - startTime}ms`);

    //Locator will return null/undefined if there is not image
    const imgElements = await page.locator(imgSelector).all();
    const srcList: (string | null)[] = [];

    for (const img of imgElements) {
        const src = await img.getAttribute("src");
        srcList.push(src);
    }

    await browser.close();

    return srcList;
}

export function scrapeLikeCount(scriptString: string): number | null
{
  const likeCountRegex: RegExp = /"reaction_count":{"count":(\d+)}/g;
  let likeCount = likeCountRegex.exec(scriptString);
  return likeCount ? Number(likeCount[1]) : null;
}

export function scrapeCommentCount(scriptString : string): number | null
{
  const commentCountRegex: RegExp = /{"comments":{"total_count":(\d+)}}/g;
  let commentCount = commentCountRegex.exec(scriptString);
  return commentCount ? Number(commentCount[1]) : null;
}

export function scrapeShareCount(scriptString: string): number | null
{
  const commentCountRegex: RegExp = /"share_count":{"count":(\d+),/g;
  let shareCount = commentCountRegex.exec(scriptString);
  return shareCount ? Number(shareCount[1]) : null;
}

export async function getScript(url: string): Promise<string[] | null>
{
  chromium.use(StealthPlugin())
  const browser: Browser = await chromium.launch();
  const page: Page = await browser.newPage();
  
  let startTime = Date.now();
  await page.goto(url, gotoOptions);
  console.log(`Script goto took: ${Date.now() - startTime}ms`);

  const scriptElementHandles = await page.$$("script");
  const scriptTexts: string[] = [];
  console.log(scriptElementHandles.length);
  let txt = "";
  let scriptText = null;

  let largestDataContentLen: [(null | ElementHandle), number] = [null, 0];
  for (const scriptHandle of scriptElementHandles) {
    let dataContentLen = await scriptHandle.getAttribute("data-content-len");
    if (dataContentLen &&  parseInt(dataContentLen) > largestDataContentLen[1])
    {
      largestDataContentLen[0] = scriptHandle;
      largestDataContentLen[1] = parseInt(dataContentLen);
    }
    scriptText = await largestDataContentLen[0]?.textContent();
    // console.log(scriptText)
    // const text = await scriptHandle.evaluate((node) => node.textContent);
    // if (text) {
    //   scriptTexts.push(text);
    //   txt+=(text+"\n");
    // }
  }
  Bun.write("output.html", await page.content() ? await page.content() : "");
  if (scriptText)
  {
    scriptTexts.push(scriptText);
  }
  await browser.close();
  return scriptTexts;

}

interface Reactions
{
  likes: number;
  shares: number;
  comments: number;
}

export async function scrapeReactions(url: string): Promise<Reactions>
{
  let res: Reactions = {likes: 0, shares: 0, comments: 0};
  const bigScripts: (string[] | null) = await getScript(url);
  bigScripts?.forEach((script) => {
    if(script)
    {
      const cc = scrapeCommentCount(script);
      const sc = scrapeShareCount(script);
      const lc = scrapeLikeCount(script);
      res.comments = cc ? cc : 0;
      res.shares = sc ? sc : 0;
      res.likes = lc ? lc : 0;
    }
  });
  return res;
}

export function scrapeTimeStamp(scriptString: string): number | null
{
  const timestampRegex: RegExp = /"creation_time":(\d+),/g;
  let timestamp = timestampRegex.exec(scriptString);
  return timestamp ? Number(timestamp[1]) : null;
}


export async function initializeBrowser(url: string): Promise<[Page, Browser]>
{
  chromium.use(StealthPlugin())
  const browser: Browser = await chromium.launch();
  const page: Page = await browser.newPage();
  
  let startTime = Date.now();
  await page.goto(url, gotoOptions);
  console.log(`Page goto took: ${Date.now() - startTime}ms`);

  return [page, browser];
}