import { chromium } from 'playwright-extra';
import StealthPlugin from 'puppeteer-extra-plugin-stealth';
import { Browser, ElementHandle, Locator, Page } from 'playwright';
import {detectAll, supportedLanguages, langName, toISO3 } from 'tinyld/heavy'
import { HTTPException } from 'hono/http-exception';
const fs = require('node:fs');
interface gotoOptions {
  referer?: string;
  timeout?: number;
  waitUntil?: "load" | "domcontentloaded" | "networkidle" | "commit";
}

const gotoOptions: gotoOptions = { timeout: 4000, waitUntil: 'load' }

export async function scrapeName(url: string): Promise<string | null>
{
  chromium.use(StealthPlugin())
  const browser: Browser = await chromium.launch();
  const page: Page = await browser.newPage();

  try {
      let startTime = Date.now();
      await page.goto(url, gotoOptions);
      console.log(`Name goto took: ${Date.now() - startTime}ms`);

      const nameElement = await page.locator('[property="og:title"]').first();
      const actualName = await nameElement.getAttribute('content');

      return actualName;
  } catch (error) {
      await browser.close();
      // console.error('An error occurred:', error);
      return null;
  } finally {
      await browser.close();
  }

}

export async function scrapePostText(url: string): Promise<string[] | null>
{
    chromium.use(StealthPlugin())
    const browser: Browser = await chromium.launch();
    const page: Page = await browser.newPage();

    try {
        let startTime = Date.now();
        await page.goto(url, gotoOptions);
        console.log(`Post text goto took: ${Date.now() - startTime}ms`);
      // Consider data-ad-preview="message" can have more than one element for reposts/reply posts
        const postElement = await page.locator('[data-ad-preview="message"]').first();
        const contentSpan = await postElement.locator('div > div > span').first();
        const textBlockList = await contentSpan.locator('> div').all();
        // console.log(textBlockList.length);
        let textContentList:string[] = [];
        for (const textBlock of textBlockList) {
            const text = await textBlock.innerText();
            textContentList.push(text);
        }
        return textContentList;
    } catch (error) {
        await browser.close();
        // console.error('An error occurred:', error);
        return null;
    } finally {
        await browser.close();
    }
}



export async function scrapeDate(url: string): Promise<string | null> {
    chromium.use(StealthPlugin())
    const browser: Browser = await chromium.launch();
    const page: Page = await browser.newPage();
  
    try {
        let startTime = Date.now();
        await page.goto(url, gotoOptions);
        console.log(`Date goto took: ${Date.now() - startTime}ms`);

        const parentElement = (await page.locator('[aria-labelledby]').all())[1];
    //   const childDiv = await parentElement.locator('span').first();
      
      const spans = await page.evaluate(() => {
        const parentElements = document.querySelectorAll('[aria-labelledby]');
        if (parentElements.length < 2) {
          throw new Error('Not enough elements found');
        }
        const childDiv : HTMLSpanElement | null = parentElements[1].querySelector('span');
        if (!childDiv) {
          throw new Error('Child div not found');
        }
        const spans = childDiv.querySelectorAll('span');
        return Array.from(spans).map(span => {
          return [span.textContent, (span.offsetTop === 0 ? span.offsetLeft : null)];
        });
      });
  
      // console.log(spans);
      
      //Remove all null values because they are fake characters
      const filteredSpans = spans.filter((el) => el[1] !== null);
      //Sort real characters by leftoffset to get true ordering
      filteredSpans.sort((a, b) => (a[1] as number) - (b[1] as number));
      //Add all sorted characters to get same date as displayed
      const date = filteredSpans.map(x => x[0]).join('');
      // console.log(filteredSpans);
  
      return date;
    } catch (error) {
      console.error('An error occurred:', error);
      await browser.close();
      return null;
    } finally {
      await browser.close();
    }
}


export async function scrapeImages(url: string): Promise<(string | null)[]>
{
  //Through img tags, then image tags with alt
  //Consider testing no image, multiple images, repost images
  //Upon observation, alt values are generated by facebook, and
  //More than one image leaves an empty alt value.
  //Reposts have a "No photo description available." alt value
    
    const imgSelector = `div > img[alt]`
    const browser: Browser = await chromium.launch();
    const page: Page = await browser.newPage();
    chromium.use(StealthPlugin())
    let startTime = Date.now();
    await page.goto(url, gotoOptions);
    console.log(`Image goto took: ${Date.now() - startTime}ms`);

    //Locator will return null/undefined if there is not image
    const imgElements = await page.locator(imgSelector).all();
    const srcList: (string | null)[] = [];

    for (const img of imgElements) {
        const src = await img.getAttribute("src");
        srcList.push(src);
    }

    await browser.close();

    return srcList;
}

export function scrapeLikeCount(scriptString: string): number | null
{
  const likeCountRegex: RegExp = /"reaction_count":{"count":(\d+)}/g;
  let likeCount = likeCountRegex.exec(scriptString);
  return likeCount ? Number(likeCount[1]) : null;
}

export function scrapeCommentCount(scriptString : string): number | null
{
  const commentCountRegex: RegExp = /{"comments":{"total_count":(\d+)}}/g;
  let commentCount = commentCountRegex.exec(scriptString);
  return commentCount ? Number(commentCount[1]) : null;
}

export function scrapeShareCount(scriptString: string): number | null
{
  const commentCountRegex: RegExp = /"share_count":{"count":(\d+),/g;
  let shareCount = commentCountRegex.exec(scriptString);
  return shareCount ? Number(shareCount[1]) : null;
}

export async function getScript(url: string): Promise<string[] | null>
{
  chromium.use(StealthPlugin())
  const browser: Browser = await chromium.launch();
  const page: Page = await browser.newPage();
  
  let startTime = Date.now();
  await page.goto(url, gotoOptions);
  console.log(`Script goto took: ${Date.now() - startTime}ms`);
  
  // const content = await page.content();
  // fs.writeFileSync("output.html", content ? content : "");

  const scriptElementHandles = await page.$$("script");
  const scriptTexts: string[] = [];
  console.log(scriptElementHandles.length);
  let txt = "";
  let scriptText = null;

  let largestDataContentLen: [(null | ElementHandle), number] = [null, 0];
  for (const scriptHandle of scriptElementHandles) {
    let dataContentLen = await scriptHandle.getAttribute("data-content-len");
    if (dataContentLen &&  parseInt(dataContentLen) > largestDataContentLen[1])
    {
      largestDataContentLen[0] = scriptHandle;
      largestDataContentLen[1] = parseInt(dataContentLen);
    }
    scriptText = await largestDataContentLen[0]?.textContent();
    // console.log(scriptText)
    const text = await scriptHandle.evaluate((node) => node.textContent);
    if (text) {
      scriptTexts.push(text);
      txt+=(text+"\n");
    }
  }
  // Bun.write("output.html", await page.content() ? await page.content() : "");
  // Bun.write("output.html", txt);
  if (scriptText)
  {
    scriptTexts.push(scriptText);
  }
  await browser.close();
  return scriptTexts;

}

interface Reactions
{
  likes: number;
  shares: number;
  comments: number;
}

export async function scrapeReactions(url: string): Promise<Reactions>
{
  let res: Reactions = {likes: 0, shares: 0, comments: 0};
  const bigScripts: (string[] | null) = await getScript(url);
  bigScripts?.forEach((script) => {
    if(script)
    {
      const cc = scrapeCommentCount(script);
      const sc = scrapeShareCount(script);
      const lc = scrapeLikeCount(script);
      res.comments = cc ? cc : 0;
      res.shares = sc ? sc : 0;
      res.likes = lc ? lc : 0;
    }
  });
  return res;
}

function scrapeReactionsbyString(scriptString: string): Reactions
{
  let likeCount = scrapeLikeCount(scriptString);
  let commentCount = scrapeCommentCount(scriptString);
  let shareCount = scrapeShareCount(scriptString);

  return {
    likes: likeCount ? likeCount : 0,
    comments: commentCount ? commentCount : 0,
    shares: shareCount ? shareCount : 0
  }
}

export function scrapeTimeStamp(scriptString: string): number | null
{
  const timestampRegex: RegExp = /"creation_time":(\d+),/g;
  let timestamp = timestampRegex.exec(scriptString);
  return timestamp ? Number(timestamp[1]) : null;
}


async function initializeBrowser(url: string): Promise<[Page, Browser]>
{
  chromium.use(StealthPlugin())
  const browser: Browser = await chromium.launch();
  const page: Page = await browser.newPage();
  
  let startTime = Date.now();
  await page.goto(url, gotoOptions);
  console.log(`Page goto took: ${Date.now() - startTime}ms`);

  return [page, browser];
}

async function scrapeImageWithBrowser(page: Page): Promise<string[] | null>
{
  const imgSelector = `div > img[alt]`;
  try
  {
    const imgElements = await page.locator(imgSelector).all();
    const srcList: string[] = [];

    for (const img of imgElements)
    {
      const src = await img.getAttribute("src");
      if (src)
      {
        srcList.push(src);
      }
    }
    return srcList;
  }
  catch(error)
  {
    return null;
  }
}

async function scrapePostTextWithBrowser(page: Page): Promise<string[] | null>
{
  try
  {
    const postElement = await page.locator('[data-ad-preview="message"]').first();
    const contentSpan = await postElement.locator('div > div > span').first();
    const textBlockList = await contentSpan.locator('> div').all();
    let textContentList:string[] = [];
    for (const textBlock of textBlockList) {
        const text = await textBlock.innerText();
        textContentList.push(text);
    }
    return textContentList;
  }
  catch(error)
  {
    return null;
  }
}

async function scrapeNameWithBrowser(page: Page): Promise<string | null>
{
  try
  {
    const nameElement = await page.locator('[property="og:title"]').first();
    const actualName = await nameElement.getAttribute('content');
    return actualName;
  }
  catch (error) {
    return null;
  }
}

async function scrapeScriptTextWithBrowser(page: Page): Promise<string[] | null>
{
  const scriptElementHandles = await page.$$("script");
  const scriptTexts: string[] = [];
  // console.log(scriptElementHandles.length);
  let txt = "";
  let scriptText = null;

  // let largestDataContentLen: [(null | ElementHandle), number] = [null, 0];
  // for (const scriptHandle of scriptElementHandles) {
  //   let dataContentLen = await scriptHandle.getAttribute("data-content-len");
  //   if (dataContentLen &&  parseInt(dataContentLen) > largestDataContentLen[1])
  //   {
  //     largestDataContentLen[0] = scriptHandle;
  //     largestDataContentLen[1] = parseInt(dataContentLen);
  //   }
  //   scriptText = await largestDataContentLen[0]?.textContent();
  // }
  async function tryContentOrAttribute(scriptLocator: Locator, nTimes: number, method: 'content' | 'attribute',  timeout? : number): Promise<string | null>
  {
    timeout = timeout ? timeout : 500;
    while(nTimes > 0)
    {
      try
      {
        if(method === 'content')
        {
          return await scriptLocator.textContent();
        }
        else if(method === 'attribute')
        {
          return await scriptLocator.getAttribute("data-content-len");
        }
      }
      catch(error)
      {
        console.log("retried")
        nTimes--;
      }
    }
    return null;
  }
  let scriptLocators = await page.locator('script').all();
  let maxContentLen: [string, number] = ["", 0];
  for (const scriptLocator of scriptLocators)
  {
    let contentLen = null;

    contentLen = await tryContentOrAttribute(scriptLocator, 3, 'attribute', 300);
    if(contentLen)
    {
      let dataLen = parseInt(contentLen)
      if (dataLen > maxContentLen[1])
      {
        let attrib = await tryContentOrAttribute(scriptLocator, 3, 'content', 300);
        if(!attrib)
        {
          throw new HTTPException(500, { message: 'Failed to get content' });
        }
        maxContentLen[0] = attrib;
        maxContentLen[1] = dataLen;
      }
    }
  }

  if (maxContentLen[0] === "")
  {
    return null
  }
  scriptTexts.push(maxContentLen[0]);
  return scriptTexts;
}

export function scrapeComments(scriptString: string, topNComments? : number): string[]
{
  const commentRegex = /"text":"((?:[^"\\]|\\.)*)","ranges"/g;
  const matches: RegExpExecArray[]  = Array.from(scriptString.matchAll(commentRegex));
  let res: string[] = [];
  if (!topNComments)
  {
    topNComments = matches.length;
  }
  while(matches.length > 0 && topNComments > 0)
  {
    const shiftedMatch = matches.shift()?.[1];
    if (shiftedMatch !== undefined)
    {
      // console.log(shiftedMatch.replace(/\\"/g, '"'));
      res.push(shiftedMatch.replace(/\\"/g, '"'));
    }
  }
  return res;
}

export async function scrapePostAllAtOnce(url: string)
{
  console.time("Scrape Time");
  let retries = 0;
  let [page, browser]: [(Page | null), (Browser | null)] = [null, null];
  while(retries < 3 && (!page && !browser))
  {
    try
    {
      [page, browser] = await initializeBrowser(url);
    }
    catch(error)
    {
      console.log(`Failed to initialize browser. Retrying... [try #${retries}]`);
      retries++;
    }
  }
  if(!page || !browser)
  {
    throw new Error("Failed to initialize browser");
  }
  const scriptText = await scrapeScriptTextWithBrowser(page);
  const promises =  
  {
    name: scrapeNameWithBrowser(page),
    postText: scrapePostTextWithBrowser(page),
    images: scrapeImageWithBrowser(page),
    // scriptText: scriptText,
  };
  let resultMap = new Map<string, string | null | string[] | number | Reactions>();
  console.timeEnd("Scrape Time");

  await Promise.allSettled(Object.values(promises))
  .then(async (results) => {
    Object.keys(promises).forEach((key, index) => {
      if (results[index].status === 'fulfilled')
      {
        resultMap.set(key, results[index].value);
      } 
      else
      {
        resultMap.set(key, null);
      }
    });

    let noRejections: boolean = results.every((res) => res.status == 'fulfilled')
    if(!noRejections)
    {
      console.error(JSON.stringify(Object.fromEntries(resultMap)))
      throw new HTTPException(500, { message: 'Scraping failed' })
    }
  });
  // resultMap.set('scriptText', scriptText);
  let sc = scriptText;
  if (sc)
  {
    let reactions: Reactions = scrapeReactionsbyString(sc[0]);
    let comments: string[] = scrapeComments(sc[0]);
    let timestamp = null;
    if (sc.length >= 1) {
      timestamp = scrapeTimeStamp(sc[0]);
    } else {
      throw new HTTPException(500, { message: `Invalid scriptText for scraping reaction sc type is: ${typeof sc} sc length is: ${sc?.length}` });
    }
    if (reactions) {
      resultMap.set('reactions', reactions);
    }
    if (timestamp) {
      resultMap.set('timestamp', timestamp);
    }
    if (comments) {
      resultMap.set('comments', comments);
    }
  }
  await browser.close();
  // resultMap.delete('scriptText');
  return (Object.fromEntries(resultMap));
}

export function topLangs(text: string, topN: number): string[]
{
  let detected:{lang: string; accuracy: number;}[] = detectAll(text);
  let topLangs: string[] = [];
  detected = detected.filter((lang) => lang.accuracy >= 0.5);
  for (const lang of detected)
  {
    topLangs.push(langName(toISO3(lang.lang)));
  }
  return topLangs.slice(0, topN);
}